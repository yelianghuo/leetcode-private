



租户1  
    数据管理 azCode1  dm-metadata-mg,               , dm-right-mq 
    数据管理 azCode2  dm-metadata-mg, dm-right-query


/v2/zone/{azCode2}/release/upgrade  
body: [dm-right-mq]


健康检查依赖的接口

1.  http://gw.internal-bigdata.com:8001/operation/service/http  endpoint-gateway

2.  http://project.internal-bigdata.com:8070/project/api/projects/all?tenantId=68&serviceIds=180  项目管理

3.  http://em.internal-bigdata.com:8081/space/getNs    endpoints-manager

4.  http://gw.internal-bigdata.com:8001+定义好的path  健康检查地址  endpoint-gateway
  








你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。

如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj > attacki 且 defensej > defensei 。

返回 弱角色 的数量。

 

示例 1：

输入：properties = [[5,5],[6,3],[3,6]]
输出：0
解释：不存在攻击和防御都严格高于其他角色的角色。
示例 2：

输入：properties = [[2,2],[3,3]]
输出：1
解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。
示例 3：

输入：properties = [[1,5],[10,4],[4,3]]
输出：1
解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。
 

提示：

2 <= properties.length <= 105
properties[i].length == 2
1 <= attacki, defensei <= 10


func numberOfWeakCharacters(properties [][]int) int {
    sort.Slice(properties, func(i, j int) bool {
        return properties[i][0] < properties[j][0]
    })
    curMax := 0
    ans := 0
    for i := len(properties)-1; i >= 0; i-- {
        if properties[i][1] < curMax {
            ans++
        } else {
            curMax = properties[i][1]
        }
    }
    return ans
}

4,3 10,4 1,5

1,5 4,3 10,4


2 0 1
1 0 2

0 1
0 1

0 2 1
2 1 0

3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
示例 4:

输入: s = ""
输出: 0

func lengthOfLongestSubstring(s string) int {
    if len(s) == 0 {
        return 0
    }
    start := 0
    res := 1
    cntMap := make(map[byte]int, 0)
    cntMap[s[0]] = 0
    for i := 1; i < len(s); i++{
        if item, ok := cntMap[s[i]]; ok {
            for t := start; t <= item; t++ {
                delete(cntMap, s[t])
            }
            start = item+1
        }
        cntMap[s[i]] = i
        if (i-start+1) > res {
            res = i-start+1
        }
    }
    return res
}



给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

 

示例 1:

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: nums =  [3,3,7,7,10,11,11]
输出: 10
 

提示:

1 <= nums.length <= 105
0 <= nums[i] <= 105

0 1 2 3 4 5 6 7 8
1,1,2,3,3,4,4,8,8

3,3,7,7,10,11,11

func singleNonDuplicate(nums []int) int {
    res := 0

    for _, v = range nums {
        res ^= v
    }
    return res
}

func check(nums []int, i int) {
    if (i & 1)  == 1 {
        if (mid-1) >= 0 && nums[mid-1] == nums[mid] {
            return true
        } else {
            return false
        }
    } else {
        if (mid+1) < len(nums) && nums[mid] == nums[mid+1] {
            return true
        } else {
            return false
        }
    }
}

func singleNonDuplicate(nums []int) int {
    if len(nums) == 1 {
        return nums[0]
    }
    start := 0
    end := len(nums)-1
    for start < end {
        mid := (end-start+1) / 2
        if check(nums, mid) {
            start = mid + 1
        } else {
            end = mid
        }
    }
    return start
}

给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。

幸运数是指矩阵中满足同时下列两个条件的元素：

在同一行的所有元素中最小
在同一列的所有元素中最大
 

示例 1：

输入：matrix = [[3,7,8],[9,11,13],[15,16,17]]
输出：[15]
解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
示例 2：

输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
输出：[12]
解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。
示例 3：

输入：matrix = [[7,8],[1,2]]
输出：[7]
 

提示：

m == mat.length
n == mat[i].length
1 <= n, m <= 50
1 <= matrix[i][j] <= 10^5
矩阵中的所有元素都是不同的


[[3,7,8]
,[9,11,13]
,[15,16,17]]

func findMin(row int, matrix [][]int) (ti, tj int) {
    ti = row
    tmpMin := math.MaxInt32
    for i := 0; i < len(matrix[0]); i++ {
        if matrix[row][i] < tmpMin {
            tmpMin = matrix[row][i]
            tj = i
        }
    }
    return
}

func checkMax(row, col int, matrix [][]int) bool {
    for i := 0; i < len(matrix); i++ {
        if matrix[i][col] > matrix[row][col] {
            return false
        }
    }
    return true
}

func luckyNumbers (matrix [][]int) []int {
    res := []int{}
    for i := 0; i < len(matrix); i++ {
        row, col := findMin(i, matrix)
        if checkMax(row, col, matrix) {
            res = append(res, matrix[row][col])
        }
    }
    return res
}


给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。

一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。

返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。

 

示例 1：


输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
[
    [0,0,0,1,1,1,0,1,0,0],
    [1,1,0,0,0,1,0,1,1,1],
    [0,0,0,1,1,1,0,1,0,0],
    [0,1,1,0,0,0,1,0,1,0],
    [0,1,1,1,1,1,0,0,1,0],
    [0,0,1,0,1,1,1,1,0,1],
    [0,1,1,0,0,0,1,1,1,1],
    [0,0,1,0,0,1,0,1,0,1],
    [1,0,1,0,1,1,0,0,0,0],
    [0,0,0,0,1,1,0,0,0,1]]

[
    [0,0,0,0],
    [1,0,1,0],
    [0,1,1,0],
    [0,0,0,0]]

func isEdge(i, j, m, n int) bool {
    if i == 0 || i == m-1 || j == 0 || j == n-1 {
        return true
    } 
    return false
}

// 无法走到边界
func dfs(i, j int, grid [][]int, visited [][]bool) bool {
    var flag = [4][2]int {{-1, 0},{1, 0},{0, -1},{0, 1}}
    m, n := len(grid), len(grid[0])
    if isEdge(i, j, m, n) {
        return true
    }
    visited[i][j] = true
    for _, item := range flag {
        x , y := i+item[0], j+item[1]
        if x < 0 || x >= m || y < 0 || y >= n {
            continue
        }
        if visited[x][y] == true || grid[x][y] == 0{
            continue
        }
        if dfs(x, y, grid, visited) {
            return true
        }
    }
    return false
}

func initVisited(visited [][]bool) {
    m, n := len(visited), len(visited[0])
    for i := 0; i < m; i++ {
        for j := 1; j < n; j++ {
            visited[i][j] = false
        }
    }
}
func dfs1(i, j int, grid[][]int) {
    m, n := len(grid), len(grid[0])
    if i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1 {
        grid[i][j] = 0
        dfs1(i-1, j, grid)
        dfs1(i+1, j, grid)
        dfs1(i, j-1, grid)
        dfs1(i, j+1, grid)
    }
}
func collect(visited [][]bool, grid [][]int) int {
    res := 0
    m, n := len(visited), len(visited[0])
    for i := 0; i < m; i++ {
        for j := 1; j < n; j++ {
            if visited[i][j] == true {
                res++
                grid[i][j] = 0
            }
        }
    }
    return res
}

func numEnclaves(grid [][]int) int {
    m, n := len(grid), len(grid[0])
    res := 0
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if isEdge(i, j, m, n) && grid[i][j] == 1  {
                dfs1(i, j, grid)
            }
        }
    }
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == 1 {
                res++
            }
        }
    }
    return res
}

var dir = [4][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}
func islandPerimeter(grid [][]int) int {
    oneNums := 0
    edgeNum := 0
    res := 0
    m, n := len(grid), len(grid[0])
    for i, row := range grid {
        for j, v := range row {
            if v == 1 {
                res++
                for _, item := range dir {
                    x := i + item[0]
                    y := j + item[1]
                    if x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1 {
                        edgeNum++
                    }
                }
            }
        }
    }
    return oneNums*4 - edgeNum
}


有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。

如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。

你可以：

装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空
 

示例 1: 

输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
解释：来自著名的 "Die Hard"
示例 2:

3 -> 5
3 -> 5
1 -> 5 
3 -> 5 = 4

输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
示例 3:

输入: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3
输出: true
 

提示:

1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106

type State struct {
    x, y int
}

func dfs(remainX, remainY, jug1Capacity, jug2Capacity, target int, stateMap map[State]bool) bool {
    if (remainX+remainY) == target {
        return true
    }
    if _, ok := stateMap[State{remainX, remainY}]; ok {
        return false
    }
    stateMap[State{remainX, remainY}] = true
    // x灌满
    tmpX, tmpY := jug1Capacity, remainY
    if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
        return true
    }
    // y灌满
    tmpX, tmpY = remainX, jug2Capacity
    if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
        return true
    }
    // x空
    tmpX, tmpY = 0, remainY
    if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
        return true
    }
    // y空
    tmpX, tmpY = remainX, 0
    if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
        return true
    }
    // x - > y y满或者x空
    // y满
    if (remainX+remainY) > jug2Capacity {
        tmpX, tmpY = remainX-(jug2Capacity-remainY), jug2Capacity
        if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
            return true
        }
    } else {
        tmpX, tmpY = 0, remainX+remainY
        if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
            return true
        }
    }
    // y - > x x满或者y空
    if (remainX+remainY) > jug1Capacity {
        tmpX, tmpY = jug1Capacity, remainY-(jug1Capacity-remainX)
        if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
            return true
        }
    } else {
        tmpX, tmpY = remainX+remainY, 0
        if dfs(tmpX, tmpY, jug1Capacity, jug2Capacity, target, stateMap) {
            return true
        }
    }
    return false
}

func canMeasureWater(jug1Capacity int, jug2Capacity int, targetCapacity int) bool {
    var stateMap = map[State]int{}
    return dfs(0, 0, jug1Capacity, jug2Capacity, targetCapacity, stateMap)
}


 5
2 -3
 4
2 -3

 5
2 -5
 2
2 -5

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func create(root *TreeNode) {
    if root == nil {
        return 0
    }
    tmp := root.Val + create(root.Left) + create(root.Right)

}

func pre(root *TreeNode, cntMap map[int]int) {
    if root == nil {
        return 
    }
    cntMap[root.Val]++
    pre(root.Left)
    pre(root.Right)
}

func findFrequentTreeSum(root *TreeNode) []int {
    create(root)
    var res []int
    cntMap := make(map[int]int, 0)
    pre(root, cntMap)
    tmpMin := math.MinInt32
    for _, v := range cntMap {
        if v > tmpMin {
            tmpMin = v
        }
    }
    for k, v := range cntMap {
        if v == tmpMin {
            res = append(res, k)
        }
    }
    return res
}


索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。

假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。

 

示例 1:

输入: A = [5,4,0,3,1,6,2]
输出: 4
解释: 
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
 

提示：

N是[1, 20,000]之间的整数。
A中不含有重复的元素。
A中的元素大小在[0, N-1]之间

func arrayNesting(nums []int) int {
    
    maxLen := 0
    curLen := new(int)
    visited := make([]bool, len(nums))
    var dfs func()
    dfs = func (cur int) {
        if visited[cur] == true {
            if curLen > maxLen {
                maxLen = *curLen
                curLen = 0
            }
        }
        curLen++
        visited[cur] = true
        dfs(nums[cur])
    }
    for i, _ := range nums {
        dfs(i)
    }
    return maxLen
}


给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4

func lengthOfLIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    cnt := make([]int, len(nums))
    cnt[0] = 1
    res := 1
    for i := 1; i < len(nums); i++ {
        cnt[i] = 1
        for j := i-1; j >= 0; j-- {
            if nums[i] > nums[j] {
                if (cnt[j] + 1) > cnt[i] {
                    cnt[i] = cnt[j] + 1
                }
            }
        }
        if cnt[i] > res {
            res = cnt[i]
        }
    }
    return res
}

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

 
示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

func findContentChildren(g []int, s []int) int {
    sort.Ints(g)
    sort.Ints(s)
    ans := 0
    i := 0
    j := 0
    for i < len(g) && j < len(s) {
        if g[i] <= s[j] {
            ans++
            i++
            j++
        } else {
            j++
        }
    }
    return ans
}

复数 可以用字符串表示，遵循 "实部+虚部i" 的形式，并满足下述条件：

实部 是一个整数，取值范围是 [-100, 100]
虚部 也是一个整数，取值范围是 [-100, 100]
i2 == -1
给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。

 

示例 1：

输入：num1 = "1+1i", num2 = "1+1i"
输出："0+2i"
解释：(1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。

输入：num1 = "1+-1i", num2 = "1+-1i"
输出："0+-2i"
解释：(1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。


func complexNumberMultiply(num1 string, num2 string) string {
    str1 := strings.Split(num1, "+")
    a, _ := strconv.Atoi(str1[0])
	b, _ := strconv.Atoi(strings.Split(str1[1], "i")[0])

	str2 := strings.Split(num2, "+")
	c, _ := strconv.Atoi(str2[0])
	d, _ := strconv.Atoi(strings.Split(str2[1], "i")[0])
    i := a*c - b*d
    j := a * d + b * c 
    return strconv.Itoa(i) + "+" + strconv.Itoa(j) + "i"
}


给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。


dp[i] 爬上第i台阶的费用

dp[i] = min(dp[i-1], dp[i-2])+cost[i]


dp[0] = cost[0] dp[1] = cost[1] dp[2] = 

func min(i, j int) int {
    if i < j {
        return i
    }
    return j
}

func minCostClimbingStairs(cost []int) int {
    dp := make([]int, len(cost))
    dp[0] = cost[0]
    dp[1] = cost[1]
    for i := 2; i < len(cost); i++ {
        dp[i] = min(dp[i-1], dp[i-2])+cost[i]
    }
    return min(dp[len(cost)-1], dp[len(cost)-2])
}

func minCostClimbingStairs(cost []int) int {
    dp := make([]int, len(cost)+1)
    dp[0] = 0
    dp[1] = 0
    for i := 2; i < len(cost); i++ {
        dp[i] = min(dp[i-1] + cost[i-1], dp[i-2]+cost[i-2])
    }
    return dp[len(cost)]
}

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

0 <= a, b, c, d < n
a、b、c 和 d 互不相同
nums[a] + nums[b] + nums[c] + nums[d] == target
你可以按 任意顺序 返回答案 。

 

示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

-2 -1 0 0 1  2


示例 2：

输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]

1
0 -1


提示：

1 <= nums.length <= 200
-109 <= nums[i] <= 109
-109 <= target <= 109


func fourSum(nums []int, target int) [][]int {
    var res [][]int
    sort.Ints(nums)
    var cntMap1 = map[int]bool {}
    for i, v := range nums {
        if _, ok := cntMap1[v]; ok {
            continue
        }
        cntMap1[v] = true

        var cntMap2 = map[int]bool {}
        for j := i+1; j < len(nums); j++ {
            if nums[i] + nums[j] > target {
                break
            }
            if _, ok := cntMap2[nums[j]]; ok {
                continue
            }
            cntMap2[nums[j]] = true
            l, r := j+1, len(nums)-1
            for l < r {
                if v+nums[j]+nums[l]+nums[r] < target {
                    l++
                } else if v+nums[j]+nums[l]+nums[r] > target {
                    r--
                } else {
                    res = append(res, []int{nums[i], nums[j], nums[l], nums[r]})
                    l++
                    r--
                    for l < r && nums[l] == nums[l-1] {
                        l++
                    }
                    for l < r && nums[r] == nums[r+1] {
                        r--
                    }
                }
            }
        }
    }
    return res
}


给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

-4 -1 -1 0 1 2




示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]

[0,0,0,0,0,0,0]

func threeSum(nums []int) [][]int {
    if len(nums) < 3 {
        return nil
    }
    var res [][]int
    sort.Ints(nums)
    var cntMap = map[int]int{}
    for i, v := range nums {
        if v > 0 {
            break
        }
        if _, ok := cntMap[v]; ok {
            continue
        }

        cntMap[v] = 1

        l, r := i+1, len(nums)-1
        for l < r {
            if v+nums[l]+nums[r] < 0 {
                l++
            } else if v+nums[l]+nums[r] > 0 {
                r--
            } else {
                res = append(res, []int{nums[i], nums[l], nums[r]})
                l++
                r--
                for l < r && nums[l] == nums[l-1] {
                    l++
                }
                for l < r && nums[r] == nums[r+1] {
                    r--
                }
            }
        }
    }
    return res
}


圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。

输入: 2
输出: 2
解释：有2种方案。分别是0->1->0和0->9->0

dp[i][j] 走i步到j点的走法数量

dp[i][j] = dp[i-1][(j-1+10)%10] + dp[i-1][(j+1)%10]

dp[0][0] = 1

  0 1 2 3 4 5 6 7 8 9
0 1 0 0 0 0 0 0 0 0 0 
1 0 1 0 0 0 0 0 0 0 1
2 2 0 1 0 0 0 0 0 0 0

* one master process


给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。


示例 1：

输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
示例 2：

输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
示例 3：

输入：s = ""


dp[i] 表明长度i字符串最长有效括号子串的长度

dp[i] = max(dp[i-1], dp[i-2] + s[i-1],s[i])

dp[0] = 0 dp[1] = 0
) ( ) ( ) )
0 0 2 2 4 4
( ( )
0 0 2


( ) ( ( ) )
0 2 2 2 4 

func max(i, j int) int {
    if i > j {
        return i 
    }
    return j
}

func longestValidParentheses(s string) int {
    if len(s) == 0 || len(s) == 1 {
        return 0
    }
    dp := make([]int, len(s))
    dp[0] = 0
    ans := 0
    for i := 1; i < len(s); i++ {
        if s[i] == ')' {
            if s[i-1] == '(' {
                dp[i] = 2 
                if i-2 >= 0 {
                    dp[i] = dp[i-2] + 2
                }
            } else {
                if i - dp[i-1] -1 >= 0 && s[i - dp[i-1] -1] == '(' {
                    dp[i] = dp[i-1] + 2
                    if (i - dp[i-1] -2) >= 0 {
                        dp[i] += dp[i - dp[i-1] -2]
                    }
                }
            }
        } 
        ans = max(ans, dp[i])
    }
    return ans
}

func longestValidParentheses(s string) int {
    var stack []int
    ans := 0
    for i, c := range s {
        if len(stack) == 0 || c == '(' {
            stack = append(stack, i)
        } else {
            if s[stack[len(stack)-1]] == '(' {
                stack = stack[:len(stack)-1]
                j := -1
                if len(stack) > 0 {
                    j = stack[len(stack)-1]
                }
                if (i-j) > ans {
                    ans = (i-j)
                }
            } else {
                stack = append(stack, i)
            }
        }
    }
    return ans
}

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]


func spiralOrder(matrix [][]int) []int {
    row, col := len(matrix), len(matrix[0])
    s, x, z, y := 0, row-1, 0, col-1
    var res []int
    for len(res) < row * col {
        for t := z; t <= y; t++ {
            res = append(res, matrix[s][t])
        }
        s++
        if s > x {
            break
        }
        for t := s; t <= x; t++ {
            res = append(res, matrix[t][y])
        }
        y--
        if y < z {
            break
        }
        for t := y; t >= z; t-- {
            res = append(res, matrix[x][t])
        }
        x--
        for t := x; t >= s; t-- {
            res = append(res, matrix[t][z])
        }
        z++
    }
    return res
}

func min(i, j int) int {
    if i < j {
        return i
    }
    return j
}

func maximalSquare(matrix [][]byte) int {
    row, col := len(matrix), len(matrix[0])
    dp := make([][]int, row)
    res := 0
    for i := 0; i < row; i++ {
        dp[i] = make([]int, col)
        for j := 0; j < col; j++ {
            if matrix[i][j] == '0' {
                continue
            }
            if i == 0 || j == 0 {
                if matrix[i][j] == '1' {
                    dp[i][j] = 1
                    if dp[i][j] > res {
                        res = dp[i][j]
                    }
                }
                continue
            }

            dp[i][j] = 1 + min(min(dp[i-1][j-1], dp[i-1][j]), dp[i][j-1])
            if dp[i][j] > res {
                res = dp[i][j]
            }
        }
    }
    //fmt.Println(dp)
    return res * res
}



给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

示例 1:

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

dp[i] 数字i分解的乘积最大

j [1-i) 
dp[i] = max()

func max(nums ...int) int {
    m := nums[0]
    for _, v := range nums {
        if v > m {
            m = v
        }
    }
    return m
}

func integerBreak(n int) int {
    dp := make([]int, n+1)

    dp[1] = 1
    for i := 2; i <= n; i++ {
        for j := 1; j < i; j++ {
            dp[i] = max(dp[i], j * (i-j), j * dp[i-j])
        }
    }
    return dp[n]
}


func mySqrt(x int) int {
    l , r := 1, x/2
    for l < r {
        mid := (r+l)/2
        if mid*mid > x {
            r = mid - 1
        } else {
            l = mid
        }
    }
    return l
}

MySQL [devops_platform]> select * from alarm_template order by update_timestamp desc limit 1 \G;
*************************** 1. row ***************************
              id: 1058
            name: 健康检查
       component: ops
   trigger_value: 1m
    template_str: {"condition":{"calc":"${source0 != null && source0.value >= 3}","type":"SIMPLE"},"sources":[{"dimensionFields":["service","host","message"],"measureFields":["value"],"id":1,"joinFields":["service","host","message"],"type":"JDBC","sql":" SELECT count(*) as value FROM ${table}  WHERE metricsName='health' AND component='ops' AND host is not null AND userId='admin' AND timestamp >= ${dt.now0s0ms().minusMinutes(3).getMillis()} AND timestamp < ${dt.now0s0ms().minusMinutes(0).getMillis()} GROUP BY service,host,message"}],"hostField":"host","contactTemplates":[{"bodyTemplate":"[${ctx.name}] 服务:${source0.service} 异常信息:[${source0.message}] 主机:${source0.host} ${isAgg ? '聚合告警,共计' + times + '次' : ''}","type":"SMS"},{"bodyTemplate":"[${ctx.name}] 服务:${source0.service} 异常信息:[${source0.message}] 主机:${source0.host} ${isAgg ? '聚合告警,共计' + times + '次' : ''}","type":"EMAIL"}],"trigger":"1m","thresholdExplain":{"type":"NONE","descriptions":[]}}
         creator: admin
create_timestamp: 1630641439726
update_timestamp: 1607655825280
           group: BUSINESS
      host_field: host
     description: NULL
       is_system:
         version: 3
      creator_id: 1
1 row in set (0.00 sec)



给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。

返回 nums 中 所有 子数组范围的 和 。

子数组是数组中一个连续 非空 的元素序列。

 

示例 1：

输入：nums = [1,2,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0 
[2]，范围 = 2 - 2 = 0
[3]，范围 = 3 - 3 = 0
[1,2]，范围 = 2 - 1 = 1
[2,3]，范围 = 3 - 2 = 1
[1,2,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4
示例 2：

输入：nums = [1,3,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0
[3]，范围 = 3 - 3 = 0
[3]，范围 = 3 - 3 = 0
[1,3]，范围 = 3 - 1 = 2
[3,3]，范围 = 3 - 3 = 0
[1,3,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4

func subArrayRanges(nums []int) int64 {
    var aseStack, descStack []int
    lMinArr := make([]int, len(nums))
    rMinArr := make([]int, len(nums))
    lMaxArr := make([]int, len(nums))
    rMaxArr := make([]int, len(nums))

    for i, v := range nums {
        for len(aseStack) > 0 && v <= nums[aseStack[len(aseStack)-1]] {
            aseStack = aseStack[:len(aseStack)-1]
        }
        lMinArr[i] = -1
        if len(aseStack) > 0 {
            lMinArr[i] = aseStack[len(aseStack)-1]
        }
        aseStack = append(aseStack, i)

        for len(descStack) > 0 && nums[descStack[len(descStack)-1]] <= v {
            descStack = descStack[:len(descStack)-1]
        }
        lMaxArr[i] = -1 
        if len(descStack) > 0 {
            lMaxArr[i] = descStack[len(descStack)-1]
        }
        descStack = append(descStack, i)
    }

    aseStack = aseStack[:0]
    descStack = descStack[:0]
    for i := len(nums)-1; i >= 0; i-- {
        for len(aseStack) > 0 && nums[i] < nums[aseStack[len(aseStack)-1]] {
            aseStack = aseStack[:len(aseStack)-1]
        }
        rMinArr[i] = -1
        if len(aseStack) > 0 {
            rMinArr[i] = aseStack[len(aseStack)-1]
        }
        aseStack = append(aseStack, i)

        for len(descStack) > 0 && nums[descStack[len(descStack)-1]] < nums[i] {
            descStack = descStack[:len(descStack)-1]
        }
        rMaxArr[i] = -1 
        if len(descStack) > 0 {
            rMaxArr[i] = descStack[len(descStack)-1]
        }
        descStack = append(descStack, i)
    }
    var ans int64
    for i := 0; i < len(nums); i++ {
        ans = ans + int64(nums[i] * ((rMaxArr[i]-i)*(i-lMaxArr) - (rMinArr-i) * (i-lMinArr)))
    }
    return ans
}

给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。

生成的测试用例保证结果符合 32-bit 整数范围。

 

示例 1：

输入：nums = [2,1,4,3], left = 2, right = 3
输出：3
解释：满足条件的三个子数组：[2], [2, 1], [3]
示例 2：

输入：nums = [2,9,2,5,6], left = 2, right = 8
输出：7


func numSubarrayBoundedMax(nums []int, left int, right int) int {
    var aseStack, descStack []int
    lMinArr := make([]int, len(nums))
    rMinArr := make([]int, len(nums))
    lMaxArr := make([]int, len(nums))
    rMaxArr := make([]int, len(nums))

    for i, v := range nums {
        for len(aseStack) > 0 && v <= nums[aseStack[len(aseStack)-1]] {
            aseStack = aseStack[:len(aseStack)-1]
        }
        lMinArr[i] = -1
        if len(aseStack) > 0 {
            lMinArr[i] = aseStack[len(aseStack)-1]
        }
        aseStack = append(aseStack, i)

        for len(descStack) > 0 && nums[descStack[len(descStack)-1]] <= v {
            descStack = descStack[:len(descStack)-1]
        }
        lMaxArr[i] = -1 
        if len(descStack) > 0 {
            lMaxArr[i] = descStack[len(descStack)-1]
        }
        descStack = append(descStack, i)
    }

    aseStack = aseStack[:0]
    descStack = descStack[:0]
    for i := len(nums)-1; i >= 0; i-- {
        for len(aseStack) > 0 && nums[i] < nums[aseStack[len(aseStack)-1]] {
            aseStack = aseStack[:len(aseStack)-1]
        }
        rMinArr[i] = len(nums)
        if len(aseStack) > 0 {
            rMinArr[i] = aseStack[len(aseStack)-1]
        }
        aseStack = append(aseStack, i)

        for len(descStack) > 0 && nums[descStack[len(descStack)-1]] < nums[i] {
            descStack = descStack[:len(descStack)-1]
        }
        rMaxArr[i] = len(nums 
        if len(descStack) > 0 {
            rMaxArr[i] = descStack[len(descStack)-1]
        }
        descStack = append(descStack, i)
    }
    var ans int
    for i := 0; i < len(nums); i++ {
        if nums[i] >= left && nums <= right {
            ans = ans + (rMaxArr[i]-i)*(i-lMaxArr)
        }
        
    }
    return ans
}

func rangeSum(path []int) int {
    ma, mi := path[0], path[0]

    for _, v := range path {
        if v > ma {
            max = v
        }
        if v < mi {
            mi = v
        }
    }
    return ma - v
}

 
func subArrayRanges(nums []int) int64 {

    var f func backTracking(i int)
    var path []int
    ans := 0
    f = func(n int) {
        if len(path) != 0 {
            fmt.Println(path)
            ans += rangeSum(path)
            return
        }
        
        for i := n; i < len(nums); i++ {
            path = append(path, nums[i])
            f(i+1)
            path = path[:len(path)-1]
        }
    }
    f(0)
    return ans
}


f(0) f(1) f(2) f(3) 


给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"


func minWindow(s string, t string) string {
    cntMap := make(map[byte]int, 0)
    cntLen := len(t)
    for i := 0; i < len(t); i++ {
        cntMap[t[i]]++
    }
    i := 0
    ans := s + s
    for j := 0; j < len(s); j++ {
        if _, ok := cntMap[s[j]]; ok {
            cntMap[s[j]]--
            if cntMap[s[j]] >= 0 {
                cntLen--
            }

            if cntLen == 0 {
                for i <= j {
                    if (j-i+1) < len(ans) {
                        ans = s[i:(j-i+1)]
                    }
                    if _, ok1 := cntMap[s[i]]; ok1 {
                        cntMap[s[i]]++
                        if cntMap[s[i]] > 0 {
                            cntLen++
                            i++
                            break
                        }
                    }
                    i++
                }
            }
        }
    }
    if ans == s + s {
        return ""
    }
    return ans
}


你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。

 

示例 1：

输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
示例 2：

输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
示例 3：

输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
示例 4：

输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。

func totalFruit(fruits []int) int {
    i, j := 0, 0 
    var cntMap = map[int]int{}
    var ans int = math.MinInt32
    for ; j < len(fruits); j++ {
        cntMap[fruits[j]]++
        if len(cntMap) <= 2 {
            if (j-i+1) > ans {
                ans = j-i+1
            }
        } else {
            for i < j {
                cntMap[fruits[i]]--
                if cntMap[fruits[i]] == 0 {
                    delete(cntMap, fruits[i]) 
                    i++
                    break
                }
                
                i++
            }
        }
        
    }
    return ans
}


假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。

 

示例 1:

输入: list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
输出: ["Shogun"]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。
示例 2:

输入:list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]，list2 = ["KFC", "Shogun", "Burger King"]
输出: ["Shogun"]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。


func findRestaurant(list1 []string, list2 []string) []string {
    var cntMap1 = map[string]int{}
    
    for i, s := range list1 {
        cntMap1[s] = i
    }
    var ans []string
    var curIndex int =  math.MaxInt32
    for i, s := range list2 {
        if n, ok := cntMap1[s]; ok {
            if (n+i) < curIndex {
                ans = []string{s}
                curIndex = n+i
            } else if (n+i) == curIndex {
                ans = append(ans, s)
            }
        }
    }
    return ans
}


/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    
    dummyHead := new(ListNode)
    dummyHead.Next = head
    pre, cur := dummyHead, dummyHead.Next
    for left > 1 {
        pre = cur
        cur = cur.Next
        left--
    }
    t := right - left
    for t > 1 {
        tmp := cur.Next
        cur.Next = tmp.Next
        tmp.Next = pre.Next
        pre.Next = tmp
        t--
    }
    return dummyHead.Next
}


6h 12h 1d 2d 4d 7d 15d


http://100.76.11.48:8036/apis/plan.i/plans/a48df5ab-b329-4dca-a400-6a318aac5a2a/export_change_table_events



select * from health_examination where component="" and push=false and withinContainer=false;

http://gw.internal-bigdata.com:8001/operation/service/http


curl -H "Content-Type: application/json" -X POST  "localhost:9096/sla-alarm/api/platform/ElasticJob/queryList"





* 多az 5天
* 告警静默  3天
* 监控告警清redis脏数据 3天
* 健康检查日志截断问题  3天

total： 14天


* 服务树，界面图形未切换
* mpp主机下没有操作系统信息
* 全局搜索查询主机能不能支持显示 2.4增加的列
* 检索内容，能否支持全部，模糊搜索


api_version: plan.i/v1
kind: task
metadata:
  name: d97caca7-0922-4924-a861-d7e7cd760c4b
  namespace: default
spec:
  display_name: image1
  estimated_seconds: 120
  target:
    batch_strategy:
      - id: 1
        tenant_id: 1
        app_type: KDQ
        resource_groups: '默认资源组,项目1'
        modules:
          - dm-metadata-mg
          - dm-metadata-query
      - id: 2
        tenant_id: 2
        app_type: KDQ
        resource_groups: '项目1,项目2'
        modules:
          - dm-metadata-mg
          - dm-metadata-query
    component: ops
    component_display_name: ''
    is_new: ''
    post_exec_machine: control
    post_task: 'yes'
    pre_exec_machine: control
    pre_task: 'yes'
    update_mode: tenant
    upgrade_modules: dm-image
    modules:
      - dm-metadata-mg
      - dm-metadata-query
  target_kind: image





api_version: plan.i/v1
kind: task
metadata:
  name: 唯一标识
  namespace: default
spec:
  display_name: xxx任务
  target_kind: image
  estimated_seconds: 15
  target:
    component: ds
    component_display_name: 数据服务
    module: dc-image
    upgrade_modules: dc-image
    batch_strategy:
      - id: 1
        tenant: 1
        app_type: KDQ
        resource_groups: "默认资源组,项目1"
        modules: "全部"
      - id: 1
        tenant: 2
        app_type: KDQ
        resource_groups: "项目1,项目2"
        modules: "dm-metadata-mg,dm-metadata-query"
    module:
      - dm-metadata-mg
      - dm-metadata-query






api_version: plan.i/v1
kind: task
metadata:
  name: 唯一标识
  namespace: default
spec:
  display_name: xxx任务
  target_kind: image
  estimated_seconds: 15
  target:
    component: ds
    component_display_name: 数据服务
    module: dc-image
    upgrade_modules: dc-image
    batch_strategy:
      - id: 1
        tenant: 1
        app_type: KDQ
        resource_groups: "默认资源组,项目1"
        modules: "全部"
      - id: 1
        tenant: 2
        app_type: KDQ
        resource_groups: "项目1,项目2"
        modules: "dm-metadata-mg,dm-metadata-query"
    modules:
      - dm-metadata-mg
      - dm-metadata-query



api_version: plan.i/v1
kind: task
metadata:
  name: d97caca7-0922-4924-a861-d7e7cd760c4b
  namespace: default
spec:
  display_name: image1
  estimated_seconds: 120
  target:
    batch_strategy:
      - id: 1
        tenant_id: 1
        app_type: KDQ
        resource_groups: '默认资源组,项目1'
        modules:
          - dm-metadata-mg
          - dm-metadata-query
      - id: 2
        tenant_id: 2
        app_type: KDQ
        resource_groups: '项目1,项目2'
        modules:
          - dm-metadata-mg
          - dm-metadata-query
    component: ops
    component_display_name: ''
    is_new: ''
    post_exec_machine: control
    post_task: 'yes'
    pre_exec_machine: control
    pre_task: 'yes'
    update_mode: tenant
    upgrade_modules: dm-image
    modules:
      - dm-metadata-mg
      - dm-metadata-query
  target_kind: image




api_version: plan.i/v1
kind: task
metadata:
  name: d97caca7-0922-4924-a861-d7e7cd760c4b
  namespace: default
spec:
  display_name: image1
  estimated_seconds: 120
  target:
    batch_strategy:
    - app_type: ""
      id: 1
      modules:
      - dm-metadata-mg
      - dm-metadata-query
      resource_group_display_name: ""
      resource_groups: 默认资源组,项目1
      tenant_id: 1
    - app_type: ""
      id: 2
      modules:
      - dm-metadata-mg
      - dm-metadata-query
      resource_group_display_name: ""
      resource_groups: 项目1,项目2
      tenant_id: 2
    component: ops
    component_display_name: ""
    is_new: ""
    modules:
    - dm-metadata-mg
    - dm-metadata-query
    post_exec_machine: control
    post_task: "yes"
    pre_exec_machine: control
    pre_task: "yes"
    update_mode: tenant
    upgrade_modules: dm-image
  target_kind: image




api_version: plan.i/v1
kind: task
metadata:
  name: 65c907cf-b94a-4e24-8db3-5dcaba312cb5
  namespace: default
spec:
  display_name: image2
  estimated_seconds: 240
  target:
    batch_strategy:
    - app_type: ""
      id: 1
      modules:
      - dm-metadata-mg
      - dm-metadata-query
      resource_group_display_name: ""
      resource_groups: 默认资源组,项目1
      tenant_id: 1
    - app_type: ""
      id: 2
      modules:
      - dm-metadata-mg
      - dm-metadata-query
      resource_group_display_name: ""
      resource_groups: 项目1,项目2
      tenant_id: 2
    component: ops
    component_display_name: ""
    is_new: ""
    post_exec_machine: control
    post_task: "yes"
    post_version: ops/ds-image-posttask-update:20220216-1450
    pre_exec_machine: control
    pre_task: "yes"
    pre_version: ops/ds-image-pretask-update:20220216-1450
    sql_version: ""
    update_mode: reset
    upgrade_modules: ds-image
    modules:
    - dm-metadata-mg
    - dm-metadata-query
  target_kind: image

